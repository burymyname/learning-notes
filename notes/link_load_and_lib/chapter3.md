## 第三章 目标文件

目标文件从结构上说，是还没有链接的可执行文件。所以内部有一些符号和地址没有调整。

### 目标文件的格式

- Windows 下 PE 格式，Linux 下 ELF
- COFF(Common File Format)：上述两种都是该格式的变种
- 动态链接库：Windows 下的 `.dll` 和 Linux 下的 `.so`
- 静态链接库：Windows 下的 `.lib` 和 Linux 下的 `.a`
- 动态链接库和静态链接库都是可执行文件格式

- ELF 格式文件类型

| ELF 文件类型 | 说明 | 实例 |
| --- | --- | --- |
| 可重定位文件 | 包含数据和代码，可以被链接为可执行文件或共享目标文件，静态链接库也属于这类 | `.o`, `.obj` |
| 可执行文件 | 直接可以执行的程序 | `.exe`, 无扩展名 |
| 共享目标文件 | 包含代码和数据，链接器可以使用其与其他可重定位文件和共享目标文件链接，产生新的目标文件，或者是动态链接器可以将几个共享目标文件与可执行文件结合，作为进程映像的一部分运行 | `.so`, `.dll` |
| 核心转储文件(core dump) | 进程以外终止的时候，系统将进程地址空间的内容和一些其他信息保存下来，没有代码段| core dump 文件|

### 目标文件是是什么样的

- section/segment：节/段
- 代码段(code section)：`.code`, `.text`
- 数据段(data section)：`.data` 

- 段表(Section table)：描述文件中各个段的数组，段表描述了文件中各个段在文件中的偏移位置和段的属性等
- 初始化的全局变量和局部静态变量在 `.data` 段
- 未初始化的全局变量和局部静态变了在 `.bss` 段，未分配内存，只预留了位置
- BSS(Block Started by Symbol)：用于定义符号并且为该符号预留给定数量的未初始化空间

- 为什么要分数据和代码在不同的段？  
    - 代码只读，数据可读可写，可以设置权限防止恶意改写程序指令
    - 有利于提高cache命中率
    - 多个进程可以共享指令这样的只读数据

### 挖掘SimpleSection.o

- 只编译不链接
    ```
    $ gcc -c SimpleSection.c
    ```

- `objdump` 查看内部结构
    ```
    $ objdump -h SimpleSection.o # 查看各个段基本信息
    ```

#### 代码段
- `objdump -s` 将所有段内容以 hex 打出来
- `objdump -d` 将所有包含指令的段反汇编

#### 数据段和只读数据段
- `.data` 段保存的是已经初始化的全局静态变量和局部静态变量
- `.rodata` 段保存的是只读数据，一般是程序中的只读变量，例如const，字符串常量

有时候编译器会把字符串常量放在 `.data` 段中

#### BSS段
- `.bss` 段存放是的未初始化的全局变量和局部静态变量
- 编译单元内部可见的静态变量是存放在 `.bss` 段中的

- 如果一个静态变量初始化为0，则会被放在 `.bss` 段中，其余会放在 `.data` 中，因为未初始化默认是0，在这里会被优化

#### 其他段
- 如果要将一个二进制文件作为目标文件中的一个段：
    ```
    $ objcopy -I binary -o elf32-i386 -B i386 image.jpg image.o
    ```

- 自定义段  
指定编译器将变量或者代码放到指定的段中
    ```
    __attribute__((section("FOO"))) int global = 42;
    __attribute__((section("BAR"))) void foo()
    ```

### ELF 文件结构描述