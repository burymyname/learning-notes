<!-- vscode-markdown-toc -->
* 1. [第一章](#1)
	* 1.1. [从 hello world 说起](#helloworld)
	* 1.2. [万变不离其宗](#basic)
	* 1.3. [站的高，看得远](#layer)
	* 1.4. [OS做什么](#OS)
		* 1.4.1. [不要让CPU打盹](#CPU)
		* 1.4.2. [设备驱动](#Driver)
	* 1.5. [内存不够怎么办](#VirtualMemory)
		* 1.5.1. [关于隔离](#Isolation)
		* 1.5.2. [分段(segmentation)](#segmentation)
		* 1.5.3. [分页(Paging)](#Paging)
	* 1.6. [众人拾柴火焰高](#Thread)
		* 1.6.1. [线程基础](#ThreadBasic)


##  1. <a name='1'></a>第一章

###  1.1. <a name='helloworld'></a>从 hello world 说起

**这一节提出来几个问题，看完书以后应该对这些问题给出清晰明确的答案**

- 程序为什么要被编译器编译后才能执行

- 编译器在把C语言程序转换成可以执行的机器码的过程中做了什么，怎么做的

- 最后编译出的可执行文件里面是什么，除了机器码还有什么？怎么存放的，怎么组织的

- `#include<stdio.h>`是什么意思，把`stdio.h`包含进来意味着这么？C语言库又是什么，怎么实现的？

- 不同编译器(MS VC, GCC)和不同的硬件平台(x86, SPARC, MIPS, ARM)以及不同的操作系统(Windows, Linux, UNIX, Solaris)，最终编译出的结果一样吗，为什么？

- Hello World 程序是怎么运行起来的，操作系统是什么装载程序的，从哪里开始执行，到哪里结束，main函数之前发生了什么？main函数结束之后发生了什么？

- 如果没有操作系统，Hello World 可以运行吗，如果一台没有 OS 的机器需要运行程序需要什么，应该怎么实现？

- `printf()`是怎么实现的，为什么参数可变，为什么能在终端输出字符？

- Hello World 程序在运行时，它在内存中是什么样子的？

###  1.2. <a name='basic'></a>万变不离其宗

- 早期计算机硬件结构
```
				  I/O device
                    |
CPU     Memory   xx controller    ...
|         |         |
+---------+---------+--------------+---- ...
                 BUS
```
- 北桥芯片：高速，协调CPU、内存和高速图形设备

- 南桥芯片：低速，连接芯片、磁盘、USB、键盘、鼠标等设备

- PCI总线，ISA总线 [TODO]

- 对称多处理器 SMP(Symmetrical Multi-Processing) <br>
每个CPU在系统所处的地位和所发挥的功能是一样的，相互对称的

- 多核处理器：只保留多个核心，共享比较昂贵的缓存部件，以一个处理器的包装出售 <br>
从程序员角度，可以把多核和SMP看作一个概念，细节上不同而已

###  1.3. <a name='layer'></a>站的高，看得远

> Any problem in computer science can be solved by another layer of indirection  
> 计算机领域的任何问题都可以通过增加一个间接的中间层解决

这句话几乎概括计算机系统软件体系结构设计要点

```
+-----------------+
|  App/Dev tools  |
+-----------------+----> OS API
| Runtime Library |
+-----------------+----> System Call
|    OS kernal    |
+-----------------+----> Hardware Specification
|     Hardware    |
+-----------------+
```
- 接口：通信的协议
- 操作系统应用程序编程接口(OS API)：由运行库提供接口
- 系统调用接口(System Call)：实现上以软中断方式提供
- 硬件规格(Hardware Specification)：硬件厂商负责提供硬件规格，OS和驱动开发者通过读硬件规格文档规定的接口标准来写OS和驱动

###  1.4. <a name='OS'></a>OS做什么

- OS的两个主要功能：
	- 提供抽象的接口
	- 管理硬件资源

- OS的主要资源类型
	- CPU
	- 存储器(内存和磁盘)
	- I/O设备

####  1.4.1. <a name='CPU'></a>不要让CPU打盹

- 多道程序：在CPU不使用的时候，通过调度其他等待CPU资源的程序启动
- 分时系统：每个程序运行一段时间后，主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一段时间，对于交互式的系统来说比较重要
- 多任务系统：OS接管所有硬件资源，自身在受硬件保护的级别，所有应用以进程的方式运行，在比系统权限更低的级别。每个进程有独立的地址空间，进程之间相互隔离。
- 抢占式：每个进程根据优先级高低分配CPU时间，但是当运行超出一定时间，OS会暂定进程，将CPU分配给其他等待的进程。**OS强制剥夺CPU资源分配给OS认为应该分配的进程。**

####  1.4.2. <a name='Driver'></a>设备驱动

- 硬件驱动程序：独立于内核，OS为硬件厂商提供一系列接口和框架，让硬件厂商按照标准开发驱动程序，使得硬件可以在操作系统上使用

以硬盘读取为例；
- 硬盘简介
	- 硬盘 -> 盘片 -> 磁道 -> 扇区 -> 512 bytes
	- 一个硬盘有多个盘片，盘片分双面，每一面的按照同心圆划分为不同磁道，每个磁道分扇区。

- 硬盘读取步骤
	- 调用`read()`系统调用
	- 驱动程序收到请求，向硬件发出硬件命令，向端口写地址和数据
	- 例如：我们需要读取1000号逻辑扇区开始的第8个扇区
		- I/O端口为：0x1F0-0x1F7和0x376-0x377，其中0x1F3-0x1F6写LBA地址，0x1F2写扇区数8，0x1F7写操作码0x20
		- 1000号逻辑扇区的LBA为0x000003E8
		- 
			```
			out 0x1F3, 0x00
			out 0x1F4, 0x00
			out 0x1F5, 0x03
			out 0x1F6, 0xE8
			out 0x1F2, 8
			out 0x1F7, 0x20
			```

###  1.5. <a name='VirtualMemory'></a>内存不够怎么办

如何将有限的物理内存分配给多个程序使用？

- 如果用物理地址分配
	- 进程之间不隔离：可以修改其他进程数据
	- 内存使用效率低：需要的空间连续，只能换入换出切换，效率低
	- 程序运行的地址不确定：涉及到程序重定位问题

解决：**虚拟地址映射**

####  1.5.1. <a name='Isolation'></a>关于隔离

- 虚拟地址空间：虚拟的，并不存在，每个进程有自己独立的虚拟空间，每个进程只能访问自己的地址空间，用虚拟内存做到了进程隔离
- 物理地址空间：可以认为物理内存，计算机只有唯一的物理地址空间

####  1.5.2. <a name='segmentation'></a>分段(segmentation)

- 分段：将程序所需要的内存空间大小的虚拟空间映射到某个地址空间  
分段解决了进程隔离和确定运行地址的问题，但内存使用效率低

####  1.5.3. <a name='Paging'></a>分页(Paging)

- 局部性原理：当程序在运行时，在一个时间段内用到的数据趋近于聚集在一个较小的连续区域内。

- 分页：把地址空间分为固定大小的页，每一页的大小由硬件决定，或者由OS选择决定页的大小。目前基本是4KB大小的页。

- 虚拟页，物理页，磁盘页

- MMU(Memory Management Unit)：内存管理单元，进行虚拟地址到物理地址的映射

	```
	+-----+  virtual addr  +-----+  physical addr   +-----------------+
	| CPU | -------------> | MMU | ---------------> | physical memory |
	+-----+                +-----+                  +-----------------+
	```
	- 所以程序中看到的是虚拟地址，经过 MMU 转换为物理地址。

###  1.6. <a name='Thread'></a>众人拾柴火焰高

####  1.6.1. <a name='ThreadBasic'></a>线程基础

**线程定义**
- 线程：轻量级进程，程序执行流的最小单元
- 线程组成：线程ID，当前指令指针PC，寄存器集合，栈
- 一个进程由多个线程组成，线程之间共享程序内存空间(代码段，数据段，堆等等)，进程级资源(打开文件，信号)
- 为什么使用线程：
	- 某个操作可能会陷入长时间等待，多线程执行可以利用等待的时间。例如：等待网络响应
	- 某个操作会消耗大量的时间(例如计算)，多线程可以让一个线程负责交互，另一个负责计算
	- 程序逻辑本身就要求并发操作
	- 多CPU或多核计算机，本身同时具备同时执行多个线程的能力
	- 相比多进程，多线程在数据共享上高效
---

**线程访问权限**
- 线程私有资源
	- 栈
	- 线程局部存储(Thread Local Storage, TLS)
	- 寄存器
- 线程共享资源
	- 全局变量
	- 堆上的数据
	- 函数里的静态变量
	- 程序代码
	- 打开的文件
---

**线程调度和优先级**
- 线程调度：当线程数量小于处理器数量时，线程的并发是真正的并行，但对于线程数量大于处理器数量时，线程的并发会收到一些阻碍
- 线程调度：处理器切换线程的行为  
	- 线程至少拥有3种状态
		- 运行：正在执行
		- 就绪：此时可以立即运行，但CPU已经被占用
		- 等待：等待某一事件的发生，无法执行
	- 线程状态切换
		```
		        无线程运行，且该线程被选中
		     +----------------------------+
             |                            |
             v                            |
		+---------+    时间片用尽      +-------+
		| running | ----------------> | ready |
		+---------+                   +-------+
             |                            ^
             |         +------+           |
             +-------> | wait | ----------+
			           +------+
		
		```
		- 时间片用尽的时候，线程从运行进入就绪状态。
		- 如果在时间片用尽前，线程就开始等待某事件，那么将进入等待状态
		- 每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行
		- 在一个等待状态的线程等待的事件发生后，线程进入就绪状态

- 优先级调度，轮转法
- I/O密集型线程频繁进入等待状态，CPU密集型线程很少等待
- 饿死：由于线程的优先级较低，执行之前总有较高优先级的线程执行，因此这个线程总是得不到执行

- 线程优先级改变方式
	- 用户指定
	- 根据等待状态的频繁程度
	- 长时间得不到执行的线程提升优先级
---

**抢占和不可抢占**
- 抢占：线程用尽时间片后，会被强制剥夺继续执行的权利，进入就绪状态
- 不可抢占线程：线程只有主动进入就绪才能调度
	- 线程主动放弃事件
	- 线程主动放弃时间片

---

**Linux的多线程**
- Windows的实现：内核有明确的进程和线程的概念，`CreateProcess` 创建进程，`CreateThread` 创建线程。
- Linux不存在真正的线程的概念。无论进程还是线程，将所有执行实体称为任务(Task)，每个任务类似于一个单线程的进程。可以通过共享内存空间来实现多线程

| 系统调用 | 作用 |
| --- | --- |
| `fork` | 复制当前进程 |
| `exec` | 使用新的可执行映像覆盖当前可执行映像 |
| `clone`| 创建子进程，从指定位置开始执行 |

`fork` 函数调用后，新的任务启动，且和本任务一起从 `fork` 函数返回，本任务返回新任务的 `pid`，新任务返回 `0`
```
pid_t pid;
if (pid = fork()) {
	// father process
} else {
	// son process
}
```
`fork` 出新任务的时候，并不会复制原任务的内存空间，而是和原任务一起共享一个COW的内存空间。
- 写时复制(Copy on Write, COW)：多个任务可以同时读取内存，但是任意一个任务试图对内存进行修改时，内存就会复制一份给该任务单独使用
- `fork` 只能产生本任务的镜像，`exec` 用新的可执行映像替换当前的可执行映像
- `clone` 产生新线程，可以从指定的位置开始执行，并且可选择共享当前进程的内存空间和文件

#### 线程安全

**竞争和原子操作**
- 原子性：不会被打断的操作
- Windows中有`InterLocked API`，专门进行原子操作
---

**同步和锁**
- 同步：多线程中，一个线程对一个数据的访问未结束时，其他现场不得对同一个数据进行访问。即对线程操作进行原子化。
- 锁(Lock)：非强制机制，每个线程访问资源之前先试图获取(Acquire)锁，并且在访问结束后释放(Release)锁，在锁被占用的时候试图获取锁，线程会等待，直到锁重新可用。
- 二元信号量：最简单的一种锁，只有两种状态，占用和非占用。适合只能被一个线程独占访问的资源。
- 信号量(Semaphore)：一个初始值为N的信号量允许N个线程并发访问。  
	线程访问的时候先获取信号量
	- 将信号量-1
	- 如果信号量<0，则进入等待状态，否则继续执行

	访问结束后，线程释放信号量
	- 将信号量+1
	- 如果信号量<1，唤醒一个等待的线程
- 互斥量(Mutex)：与二元信号量类似，资源同时仅允许一个线程访问。区别在：信号量可以被系统中的一个线程获取之后由另一个线程释放。互斥量要求哪个线程获取了互斥量，哪个线程要负责释放这个锁。
- 临界区(Critical Section)：比互斥量更加严格的同步手段，临界区的锁的获取称为进入临界区，锁的释放称为离开临界区。区别在于：互斥量和信号量在系统中的任何进程里都是可见的，临界区的作用范围仅限本进程，其他进程无法获取该锁。
- 读写锁(Read-Write Lock)：有两种获取方式：共享和独占
	- 当锁处于自由状态时，任意一种获取锁方式都可以
	- 当锁处于共享状态时，其他线程以共享的方式获取锁可以成功，以独占方式获取锁时，需要等待锁的其他所有线程释放。
	- 当锁处于独占状态时，任何其他方式获取锁都会失败  

	被用于读写场景中，读为共享状态，写为独占状态。

- 条件变量(Condition Variabl)：对于条件变量，线程可以有两种操作
	- 线程可以等待条件变量，一个条件变量可以被多个线程等待
	- 线程可以唤醒条件变量，此时所有等待该条件变量的线程都会被唤醒。

	使用条件变了可以让多个线程一起等待某个事件的发生，当事件发生时所有的线程可以一起恢复执行。
---

**可重入和线程安全**
- 一个函数被重入，说明这个函数没有执行完成。
	- 多个线程执行这个函数
	- 函数自身调用自身

- 可重入：表面函数被重入后没有副作用
	- 不使用任何局部静态或全局的非const变量
	- 不返回任何局部静态或全局的非const变量的指针
	- 仅依赖于调用方提供的参数
	- 不依赖任何单个资源的锁
	- 不掉用任何不可重入的函数

	可重入函数可以在多线程环境下使用
---

**过度优化**
- 编译器的优化可能会导致线程同步问题
- `volatile` 关键字阻止优化
	- 阻止编译器为了提高速度将一个变量缓存到寄存器不写回
	- 阻止编译器调整操作变量的指令顺序

- `barrier` 指令，阻止CPU将该指令之前的指令交换后该指令之后。


#### 多线程内部情况

- 大多数OS，都在内核里提供线程的支持，用户实际使用的线程不是内核线程，是存在与用户态的用户线程，数量不一定等同。

**三种模型**
- 一对一模型：最简单的模型，一个用户使用的线程对应一个内核使用的线程  
一般直接使用API或系统调用创建的进程均为一对一的线程  
缺点：
	- 许多OS限制了内核线程的数量，会导致用户的线程数量受到限制
	- 许多OS内核线程调度上下文切换开销大，导致用户线程的执行效率低

- 多对一模型：多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对于一对一，多对一切换快很多。  
问题：其中一个线程阻塞，所有的线程都无法执行。
- 多对多模型：多个用户线程映射到少数但不止一个内核线程上。  
一个线程阻塞不会导致所有用户线程阻塞，因为还有其他线程可以调度执行