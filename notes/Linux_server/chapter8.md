# 高性能服务器程序框架

- 服务器可以解构为三个主要模块
    - I/O 处理单元：4 种 I/O 模型和 2 种高效事件处理模型
    - 逻辑单元：2 种高效并发模型，有限状态机
    - 存储单元

## 服务器模型

### C/S 模型

### P2P 模型

## 服务器编程框架

```
+-------------+          +---------+
| I/O 处理单元 | 请求队列 | 逻辑单元 | 请求队列 | 网络存储单元 |
+-------------+          +---------+

```

- I/O 处理单元：处理客户连接，读写网络数据；作为接入服务器，实现负载均衡
- 逻辑单元：业务进程或线程；逻辑服务器
- 网络存储单元：本地数据库、文件或缓存；数据库服务器
- 请求队列：各单元之间的通信方式；各服务器之间的永久 TCP 连接

## I/O 模型

- 阻塞非阻塞
- 阻塞 I/O 执行的系统调用，可能因为无法立即完成被 OS 挂起，直到等待的事件发生为止。
- 非阻塞 I/O 执行的系统调用立即返回，不管事件是否已经发生。

- 非阻塞的 I/O 需要和其他 I/O 通知机制一起使用。
- I/O 复用是最常使用的 I/O 通知机制。应用通过 I/O 复用函数向内核注册一组事件，内核通过 I/O 复用函数把其中就绪的事件通知给应用。
- I/O 复用函数本身是阻塞的，提高效率是因为它们能够同时监听多个 I/O 事件的能力。

## 两种高效事件处理模式

- 服务器通常需要处理三类事件：I/O 事件，信号，定时事件

- 两种高效事件处理模式：Reactor，Proactor。同步常实现 Reactor 模型，异步实现 Proactor 模型

### Reactor

- 要求主线程(I/O 处理单元)只负责监听文件描述上是否有事件发生，有的话立即将该事件通知工作线程(逻辑单元)，除此外，主线程不做任何其他实质性工作。
- 使用同步 I/O 模型实现的 Reactor 模式的工作流程
    - 主线程往 epoll 内核事件表注册 socket 上的读就绪事件
    - 主线程调用 epoll_wait 等待 socket 上有数据可读
    - 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程将 socket 可读事件放入请求队列。
    - 睡眠在请求队列上的某个工作线程被唤醒，从 socket 读取数据，并处理，然后往 epoll 内核事件表注册 socket 上的写就绪事件。
    - 主线程调用 epoll_wait 等待 socket 可写
    - 当 socket 上有数据可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。
    - 睡眠在请求队列上的某个工作线程被唤醒，往 socket 上写服务器处理客户请求的结果

### Proactor

- Proactor 模式将所有的 I/O 操作交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

## 两种高效并发模式

- 并发的目的是为了让程序同时执行多个任务。如果是计算密集型，则没有优势，还会因为切换导致效率降低。如果是 I/O 密集型的，当 I/O 阻塞时，可以主动放弃 CPU，提高效率。

- 多进程，多线程

- 两种并发模式：半同步/半异步，领导者/追随者模式

### 半同步/半异步

- I/O 模型中的同步异步是指，内核向应用通知的是哪种 I/O 事件(就绪/完成)，以及谁来完成 I/O 读写(应用/内核)

- 并发模式中，同步指的是程序完全按照代码序列的顺序执行，异步是指程序的执行需要由事件来驱动。

- 同步线程用于处理客户逻辑，异步线程用于处理 I/O 事件

### 领导者/追随者模式

- 多个工作线程轮流获取事件源集合，轮流监听，分发并处理事件。
- 在任意时间点，程序都仅有一个领导者线程，负责监听 I/O 事件。而其他线程则是追随者，休眠在线程池中等待成为新的领导者
- 当前的领导者如果检测到 I/O 事件，首先要从线程池中选出新的领导者线程，然后处理 I/O 事件。

- 包含以下组件
    - Handle Set：句柄集
    - Thread Set：线程集
    - EventHandler：事件处理器
    - ConcreateEventHandler：具体的事件处理器

#### 句柄集

## 有限状态机

