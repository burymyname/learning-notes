# C++ 八股

所有的答案要建立在理解之上，否则稍微深入展开就回答不上来了。

## C 和 C++

1. const

- 修饰变量：说明该变量的值不可改变
- 修饰指针：分为指向常量的指针(指针指向的地址所存的值为常量)，常量指针(自身是常量的指针)
- 修饰引用：指向常量的引用，该引用的值不可改变，常用于形参
- 修饰成员函数：该函数不能修改成员变量

2. const 修饰指针  

    ```
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
    ```

3. 宏定义和 const

- 宏定义：相当于字符替换，预处理器处理，无类型检查，不分配内存，字符替换所以存储在代码段
- const：常量声明，编译器处理，有类型检查，分配内存，存储在数据段

4. static

- 修饰局部变量：修改存储区域和生命周期，变量存储在静态区，在main函数执行前就分配了空间，如果有初始值就存放在data段，没有初始化或者初始化为0分配在bss段

- 修饰普通函数：修改函数的链接属性，只有定义该函数所在文件内的函数可见，在项目中可以避免其他文件中的同名函数冲突

- 修饰成员变量：本质上是全局变量，所有该类的对象值保存一个该变了，不需要生成对象就可以访问该静态成员变量

- 修饰成员函数：不需要实例化对象就可以访问该函数，但是静态成员函数不能访问非静态成员，因为静态成员函数没有this指针

5. inline 内联函数

- 内联等同于：把内联函数的内容直接写在调用内联函数的地方，不用执行调用函数的行为，直接执行函数体

- 与宏定义对比：多了类型检查

- 编译器一般不内联：循环，递归，switch等复杂操作

- 在类声明中定义的函数，除了虚函数以外会自动隐式的当做内联函数

- 编译器对内联的处理步骤
    - 将inline函数体复制到inline函数调用处
    - 为inline函数中的局部变量分配空间
    - 将inline函数的输入参数和返回值映射到调用函数的局部变量空间中
    - 如果inline函数有多个返回点，则将其转变为inline函数代码块末尾的分支，用goto

- 优点：省去函数调用压栈回收的开销，比宏定义多了函数检查以及可调试。

- 缺点：代码膨胀，inline函数改变需要重新编译。

- 虚函数能不能内联？  
虚函数可以是inline，但是当虚函数表现多态性的时候不能内联，因为虚函数是运行时才能确定的特性，但是内联在编译时就需要确定替换的函数。唯一可以内联的时候是可以在编译器确定对象是哪个类的时候。

6. volatile

- 修饰类型，表示变量可以被某些编译器未知的因素修改，所以告诉编译器不应该对该对象进行优化，每次访问必须从内存中取出值。且不可乱序执行，不过 volatile 是否真正采用取决于编译器

- const 可以是 volatile，指针也可以是 volatile

7. sizeof

- 对数组，获取数组所占空间大小
- 对指针，获取指针本身所占空间大小
- C++ 中类对象大小计算
    - 影响对象大小计算因素：对齐，虚函数，虚继承
    - 空类：1，因为标准要求必须有非0大小
    - 继承空类：子类会忽略父类空类中的 1 byte
    - 字节对齐
    - 虚函数类：含有虚表指针vptr，分配4/8字节，位于内存最前端
    - 虚函数继承：如果是多继承，继承的每个父类都有一个指针指向其虚函数表。最后加上本身的虚表指针
    
8. extern "C"

- 修饰变量和函数，说明让 C++ 编译器按照 C 语言方式对声明的代码部分进行编译和链接。
- 主要为了避免 C++ 的 name mangling 对符号进行修饰导致不能与 C 语言库中的符号进行链接

9. struct 和 class 区别

- 总体上说，struct 更适合看作一个数据结构的实现，class 更适合看作一个对象的实现
- 默认访问控制：struct 是 public 的，class 是 private
- 默认继承权限：struct 是 public 的，class 是 private

10. 指针和引用区别

- 相同点：都是内存地址的概念，指针指向一块内存，引用是某块内存的别名
- 区别：
    - 指针是一个实体，引用是一个别名
    - 指针在使用过程中可以改变，引用只能在定义时初始化，不能再变
    - 引用不能为空，指针可以
    - sizeof 指针得到指针大小，引用得到对象的大小
    - 指针需要解引用操作，引用可以直接操作

## C++基础

1. this 指针

- this 指针是隐含在每一个非静态成员函数中的特殊指针，指向调用该成员函数的对象

- 当一个对象调用成员函数时，编译器会隐式传入this指针参数，存放对象的首地址。在编译时获取了首地址后放在寄存器中。

- this 指针被隐含声明为 `Class *const this`，所以不能给this赋值

- this 是一个右值，也不能取地址

2. 重载 重写 重定义

- 重载 overload：一个类中实现多个函数名相同但参数不同的函数，不能依靠返回值类型区分
- 重写 override：子类继承父类，重写了父类中的虚函数。函数名和参数，返回值相同，具体实现不同，被重写的函数必须是虚函数，访问修饰符可以不同。
- 重定义：隐藏，子类重新定义父类中相同名称的非虚函数，子类屏蔽了父类的同名函数。

3. 多态

- 面向对象三大特征：封装，继承，多态
    - 封装：把事物抽象为类，将内部信息进行隐藏
    - 继承

- 多态是以封装和继承为基础的

- C++ 多态  
    1. 重载多态：编译期，函数重载，运算符重载
    2. 子类型多态：运行期，虚函数
    3. 参数多态：编译期，类模板，函数模板
    4. 强制多态：编译/运行期，基本类型转换，自定义类型转换

- 静态多态
    - 函数重载
    - 类模板，函数模板

- 动态多态
    - 虚函数

4. 虚函数

- 父类的函数前加上 virtual 关键字，在子类重写该函数，运行时会根据对象的实际类型调用对应的函数。

- 一个类中包含虚函数的时候，编译器会为该类生成一个虚函数表，用于保存该类中虚函数的地址。如果子类继承该类，一定会有虚函数，所以派生类中也会生成自己的虚函数表。

- 每个包含虚函数的类对象实例中生成一个虚表指针，指向该类型的虚函数表，虚表指针的初始化在构造函数中完成。

- 编译器建立虚函数表的步骤：  
    1. 拷贝基类的虚函数表，如果是多继承，拷贝每个具有虚函数的基类的虚函数表
    2. 主基类：有一个基类与派生类的虚函数表共用一个虚函数表
    3. 查看派生类中是否有重写基类的虚函数，如果有，则替换虚函数表中基类的函数地址为重写的虚函数地址，同时将派生类中自身的虚函数追加到自身的虚函数表中。

- 运行时多态：在运行时，根据对象实例中的虚标指针指向的虚函数表，找到调用的虚函数实际的地址，如果是基类则虚函数表中存放的是基类虚函数的地址，如果是派生类则虚函数表中存放的派生类中虚函数的地址，由此实现多态。

- 构造函数为什么不能定义为虚函数  
    - 从作用层面来说，虚函数是为了在不知道实际对象类型的情况下，只需要知道接口就可以直接调用。但要创建一个对象，是需要知道具体对象类型的。
    - 从实现的角度来说，虚函数的调用是要通过虚表指针来找虚函数地址的，但虚表指针是在构造函数中初始化的，如果构造函数为虚函数，此时找不到虚函数表地址。

- 析构函数可以是虚函数吗？  
可以，建议写成虚函数。定义析构函数为虚函数，可以根据具体的对象类型，执行派生类的析构函数，再执行基类的析构函数，释放对应的内存，防止内存泄漏。

- 纯虚函数
    - `virtula void func() = 0`
    - 含有纯虚函数的类为抽象类，不能实例化
    - 纯虚函数可以实现也可以不实现
    - 要求派生类必须提供一个该纯虚函数的实现(去掉 `=0`)

5. 构造函数和析构函数的顺序  

- 构造函数
    1. 基类构造函数：如果有多个基类，调用顺序为在类派生表中出现的顺序，而不是成员初始化表中的顺序
    2. 成员类对象构造函数：按照对象在类汇总被声明的顺序
    3. 派生类构造函数

- 析构函数
    1. 派生类析构函数
    2. 成员类对象析构函数
    3. 基类析构函数

6. 深拷贝和浅拷贝的区别

- 使用：拷贝构造函数，赋值运算符
- 浅拷贝：值的复制
- 深拷贝：重新申请内存空间存储相同的值
- 区别在处理指针和引用的时候

7. 拷贝构造函数

- 什么时候调用拷贝构造函数？
    - 函数参数值传递
    - 函数返回值值传递
    - 一个对象通过另一个对象初始化

- 为什么拷贝构造函数必须引用传递，不能值传递？  
防止递归调用，如果以值传递，则在构建形式参数的时候，会调用拷贝构造函数，变成了无限递归调用。



## C++ 11 特性

1. 智能指针
- 为什么要使用智能指针  
方便管理指针，避免例如因为指针忘记释放造成内存泄露的问题。  
当使用智能指针管理时，超出了智能指针的作用域，智能指针会调用析构函数，不需要我们自己手动释放内存空间。

- 常用接口
    ```
    T* get(); //返回指针封装内部的指针

    T& operator*();
    T* operator->();
    T& operator=(const T& val);
    
    T* release(); // 将内部的指针置空，然后返回原指针地址，意思为不再进行管理，交由程序员管理
    
    void reset(T* ptr = nullptr); // 直接释放内部指针的内存，如果指定了ptr的值，将内部指针初始化为该值
    ```

- `auto_ptr` 采用所有权模式，C++98的方案，C++11弃用  
排他所有权模式  
缺点：
    - 复制和赋值都会转移所有权
    - STL容器中使用有风险，因为容器中的元素需要支持可复制和赋值
    - 不支持对象数组的内存管理

- `unique_ptr` 用该指针替代 `auto_ptr`  
排他所有权模式：同时只能有一个指针指向一个地址  
无法用左值赋值和赋值构造，但允许临时右值赋值构造和赋值  

