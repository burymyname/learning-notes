# C++ 八股

所有的答案要建立在理解之上，否则稍微深入展开就回答不上来了。

## C 和 C++

1. const

- 修饰变量：说明该变量的值不可改变
- 修饰指针：分为指向常量的指针(指针指向的地址所存的值为常量)，常量指针(自身是常量的指针)
- 修饰引用：指向常量的引用，该引用的值不可改变，常用于形参
- 修饰成员函数：该函数不能修改成员变量

2. const 修饰指针  

    ```
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
    ```

3. 宏定义和 const

- 宏定义：相当于字符替换，预处理器处理，无类型检查，不分配内存，字符替换所以存储在代码段
- const：常量声明，编译器处理，有类型检查，分配内存，存储在数据段

4. static

- 修饰局部变量：修改存储区域和生命周期，变量存储在静态区，在main函数执行前就分配了空间，如果有初始值就存放在data段，没有初始化或者初始化为0分配在bss段

- 修饰普通函数：修改函数的链接属性，只有定义该函数所在文件内的函数可见，在项目中可以避免其他文件中的同名函数冲突

- 修饰成员变量：本质上是全局变量，所有该类的对象值保存一个该变了，不需要生成对象就可以访问该静态成员变量

- 修饰成员函数：不需要实例化对象就可以访问该函数，但是静态成员函数不能访问非静态成员，因为静态成员函数没有this指针

5. inline 内联函数

- 内联等同于：把内联函数的内容直接写在调用内联函数的地方，不用执行调用函数的行为，直接执行函数体

- 与宏定义对比：多了类型检查

- 编译器一般不内联：循环，递归，switch等复杂操作

- 在类声明中定义的函数，除了虚函数以外会自动隐式的当做内联函数

- 编译器对内联的处理步骤
    - 将inline函数体复制到inline函数调用处
    - 为inline函数中的局部变量分配空间
    - 将inline函数的输入参数和返回值映射到调用函数的局部变量空间中
    - 如果inline函数有多个返回点，则将其转变为inline函数代码块末尾的分支，用goto

- 优点：省去函数调用压栈回收的开销，比宏定义多了函数检查以及可调试。

- 缺点：代码膨胀，inline函数改变需要重新编译。

- 虚函数能不能内联？  
虚函数可以是inline，但是当虚函数表现多态性的时候不能内联，因为虚函数是运行时才能确定的特性，但是内联在编译时就需要确定替换的函数。唯一可以内联的时候是可以在编译器确定对象是哪个类的时候。

6. volatile

- 修饰类型，表示变量可以被某些编译器未知的因素修改，所以告诉编译器不应该对该对象进行优化，每次访问必须从内存中取出值。且不可乱序执行，不过 volatile 是否真正采用取决于编译器

- const 可以是 volatile，指针也可以是 volatile

7. sizeof

- 对数组，获取数组所占空间大小
- 对指针，获取指针本身所占空间大小
- C++ 中类对象大小计算
    - 影响对象大小计算因素：对齐，虚函数，虚继承
    - 空类：1，因为标准要求必须有非0大小
    - 继承空类：子类会忽略父类空类中的 1 byte
    - 字节对齐
    - 虚函数类：含有虚表指针vptr，分配4/8字节，位于内存最前端
    - 虚函数继承：如果是多继承，继承的每个父类都有一个指针指向其虚函数表。最后加上本身的虚表指针
    
8. extern "C"

- 修饰变量和函数，说明让 C++ 编译器按照 C 语言方式对声明的代码部分进行编译和链接。
- 主要为了避免 C++ 的 name mangling 对符号进行修饰导致不能与 C 语言库中的符号进行链接

9. struct 和 class 区别

- 总体上说，struct 更适合看作一个数据结构的实现，class 更适合看作一个对象的实现
- 默认访问控制：struct 是 public 的，class 是 private
- 默认继承权限：struct 是 public 的，class 是 private

10. 指针和引用区别

- 相同点：都是内存地址的概念，指针指向一块内存，引用是某块内存的别名
- 区别：
    - 指针是一个实体，引用是一个别名
    - 指针在使用过程中可以改变，引用只能在定义时初始化，不能再变
    - 引用不能为空，指针可以
    - sizeof 指针得到指针大小，引用得到对象的大小
    - 指针需要解引用操作，引用可以直接操作

## C++基础

1. this 指针

- this 指针是隐含在每一个非静态成员函数中的特殊指针，指向调用该成员函数的对象

- 当一个对象调用成员函数时，编译器会隐式传入this指针参数，存放对象的首地址。在编译时获取了首地址后放在寄存器中。

- this 指针被隐含声明为 `Class *const this`，所以不能给this赋值

- this 是一个右值，也不能取地址

2. 重载 重写 重定义

- 重载 overload：一个类中实现多个函数名相同但参数不同的函数，不能依靠返回值类型区分
- 重写 override：子类继承父类，重写了父类中的虚函数。函数名和参数，返回值相同，具体实现不同，被重写的函数必须是虚函数，访问修饰符可以不同。
- 重定义：隐藏，子类重新定义父类中相同名称的非虚函数，子类屏蔽了父类的同名函数。

3. 多态

- 面向对象三大特征：封装，继承，多态
    - 封装：把事物抽象为类，将内部信息进行隐藏
    - 继承

- 多态是以封装和继承为基础的

- C++ 多态  
    1. 重载多态：编译期，函数重载，运算符重载
    2. 子类型多态：运行期，虚函数
    3. 参数多态：编译期，类模板，函数模板
    4. 强制多态：编译/运行期，基本类型转换，自定义类型转换

- 静态多态
    - 函数重载
    - 类模板，函数模板

- 动态多态
    - 虚函数

4. 虚函数

- 父类的函数前加上 virtual 关键字，在子类重写该函数，运行时会根据对象的实际类型调用对应的函数。

- 一个类中包含虚函数的时候，编译器会为该类生成一个虚函数表，用于保存该类中虚函数的地址。如果子类继承该类，一定会有虚函数，所以派生类中也会生成自己的虚函数表。

- 每个包含虚函数的类对象实例中生成一个虚表指针，指向该类型的虚函数表，虚表指针的初始化在构造函数中完成。

- 编译器建立虚函数表的步骤：  
    1. 拷贝基类的虚函数表，如果是多继承，拷贝每个具有虚函数的基类的虚函数表
    2. 主基类：有一个基类与派生类的虚函数表共用一个虚函数表
    3. 查看派生类中是否有重写基类的虚函数，如果有，则替换虚函数表中基类的函数地址为重写的虚函数地址，同时将派生类中自身的虚函数追加到自身的虚函数表中。

- 运行时多态：在运行时，根据对象实例中的虚标指针指向的虚函数表，找到调用的虚函数实际的地址，如果是基类则虚函数表中存放的是基类虚函数的地址，如果是派生类则虚函数表中存放的派生类中虚函数的地址，由此实现多态。

- 构造函数为什么不能定义为虚函数  
    - 从作用层面来说，虚函数是为了在不知道实际对象类型的情况下，只需要知道接口就可以直接调用。但要创建一个对象，是需要知道具体对象类型的。
    - 从实现的角度来说，虚函数的调用是要通过虚表指针来找虚函数地址的，但虚表指针是在构造函数中初始化的，如果构造函数为虚函数，此时找不到虚函数表地址。

- 析构函数可以是虚函数吗？  
可以，建议写成虚函数。定义析构函数为虚函数，可以根据具体的对象类型，执行派生类的析构函数，再执行基类的析构函数，释放对应的内存，防止内存泄漏。

- 纯虚函数
    - `virtula void func() = 0`
    - 含有纯虚函数的类为抽象类，不能实例化
    - 纯虚函数可以实现也可以不实现
    - 要求派生类必须提供一个该纯虚函数的实现(去掉 `=0`)

5. 构造函数和析构函数的顺序  

- 构造函数
    1. 基类构造函数：如果有多个基类，调用顺序为在类派生表中出现的顺序，而不是成员初始化表中的顺序
    2. 成员类对象构造函数：按照对象在类汇总被声明的顺序
    3. 派生类构造函数

- 析构函数
    1. 派生类析构函数
    2. 成员类对象析构函数
    3. 基类析构函数

6. 深拷贝和浅拷贝的区别

- 使用：拷贝构造函数，赋值运算符
- 浅拷贝：值的复制
- 深拷贝：重新申请内存空间存储相同的值
- 区别在处理指针和引用的时候

7. 拷贝构造函数

- 什么时候调用拷贝构造函数？
    - 函数参数值传递
    - 函数返回值值传递
    - 一个对象通过另一个对象初始化

- 为什么拷贝构造函数必须引用传递，不能值传递？  
防止递归调用，如果以值传递，则在构建形式参数的时候，会调用拷贝构造函数，变成了无限递归调用。

8. 虚继承

- TODO


## C++ 11 特性

### 语言可用性

#### 常量

1. 空指针 nullptr

- 替代 NULL，传统 C++ 把 NULL 和 0 视为相等，这会导致 C++ 中的重载出现混乱，C++ 11 引入 nullptr 区分空指针和 0，能够隐式转换为任何指针。

- nullptr 是 nullptr_t 类型的右值常量

2. constexpr 

- 修饰变量和函数，必须是编译阶段可以被识别的

#### 变量初始化

3. 初始化列表

- 允许构造函数或其他函数可以像参数一样使用初始化列表

- `std::initializer_list` 

- `Foo foo {1, 2, 3};`

- 顺序是定义的顺序

#### 类型推导

4. auto

- 在定义变量类型时使用 auto，让编译器自动推断类型

- 实际上 auto 只是一个占位符，在编译期会被真正的类型替代，由编译器自动推导

- auto 还可以和某些具体类型混合使用，例如 `*` 和 `&` 以及 `const`

- 应用：
    1. 类型冗长时可以让代码简洁
    2. 泛型编程，不知道变量是什么类型

5. decltype

- `decltype(exp) varname = value`

- auto 是根据右值推断变量类型，decltype 是根据括号中 exp 表达式推导出变量的类型

- 规则
    1. 如果 exp 是一个不被括号包围的表达式，或者是一个类成员访问表达式，或者是一个单独变量，类型为 exp 的类型
    2. 如果 exp 是函数调用，类型为函数返回值类型，此时调用需要带上参数和括号，但是不会真正调用
    3. 如果 exp 是一个左值，或者被括号包围，类型为 exp 的引用。`e.g: decltype((obj.x))`

- auto 只能用于类的静态成员，如果要推导类的非静态成员，用 decltype

### 运行期

6. lambda 表达式

- lambda 表达式实际上提供了一个类似匿名函数的特性，需要一个函数但是不想命名

- 定义  
    ```
    [外部变量访问方式](参数) mutable noexcept/throw() -> 返回值
    {
        // function body
    }
    ```

- lambda 表达式产生的是函数对象，称之为函数对象或仿函数。定义一个lambda 表达式后，编译器自动产生一个匿名类，重载()运算符，称为闭包类型。

- `[]` 闭包  
可以通过传值或引用的方式捕捉其作用域内的变量，实际上是拷贝了一份变量到自己的闭包(函数对象中)，因为它不能延长变量的生命周期，只是提供复制和引用的捕获语义。

- 值捕获是在 lambda 表达式被创建时就拷贝了

- 引用捕获的值会发生变化

7. 右值引用

- 左值右值：可以获取到内存地址的值为左值，不能为右值

- 右值引用：`&&`，且必须立即初始化，且只能用右值，但是可以进行修改。可以延长右值生命周期到引用结束

- 移动构造 移动赋值  TODO
直接对右值进行引用，不需要再构造临时变量进行复制，直接将右值引用的所有权转移

- std::move 本质是一个转换函数，将给定的类型转换为右值引用，实现如下，首先清除类型中的引用，加上&&并转换
    ```
    template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
    ```

- 引用传递：函数形参和实参类型都为 && 时，才会被推导为右值引用，其余情况皆为左值引用。

- 完美转发：`std::forward<T>()`，在传递参数的时候，保留参数的左右值类型。  
同样，转发也没有做任何事情，只是将参数做一个类型的转换，效果与 `static_cast<T&&>(v)` 是一样的


### 智能指针

8. 智能指针

- 为什么要使用智能指针  
方便管理指针，避免例如因为指针忘记释放造成内存泄露的问题。  
当使用智能指针管理时，超出了智能指针的作用域，智能指针会调用析构函数，不需要我们自己手动释放内存空间。

- 常用接口
    ```
    include <memory>

    T* get(); //返回指针封装内部的指针

    T& operator*();
    T* operator->();
    T& operator=(const T& val);
    
    T* release(); // 将内部的指针置空，然后返回原指针地址，意思为不再进行管理，交由程序员管理
    
    void reset(T* ptr = nullptr); // 直接释放内部指针的内存，如果指定了ptr的值，将内部指针初始化为该值
    ```

- `auto_ptr` 采用所有权模式，C++98的方案，C++11弃用  
排他所有权模式  
缺点：
    - 复制和赋值都会转移所有权
    - STL容器中使用有风险，因为容器中的元素需要支持可复制和赋值
    - 不支持对象数组的内存管理

- `unique_ptr` 用该指针替代 `auto_ptr`  
排他所有权模式：同时只能有一个指针指向一个地址  
无法用左值赋值和赋值构造，但允许临时右值赋值构造和赋值

1. `shared_ptr`

- 可以不用 new，使用 `std::make_shared<type>(value)` 分配创建传入参数中的对象，并返回指针

- 赋值会增加 ref count，`get()` 方法获取原始指针，`reset()` 减少一个 ref count，`use_count()` 查看一个对象的 ref count

2. `unique_ptr`

- 独占指针，禁止共享对象，直接赋值是非法的

- 可以用 `std::move` 转移所有权，`std::unique_ptr<Foo> p2(std::move(p1));` 或者 `p2 = std::move(p1)`

- C++ 14 提供了 `std::make_unique` 
    ```
    template<typename T, typename ...Args>
    std::unique_ptr<T> make_unique( Args&& ...args ) {
        return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
    }
    ```

3. `weak_ptr`

- shared_ptr 可能会存在循环引用的问题，解决这个问题的办法就是使用弱引用指针，弱引用不会引起引用计数增加

- `std::weak_ptr` 没有 `*` 运算符和 `->` 运算符，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在。

- `expired()` 方法能在资源未被释放时，会返回 false，否则返回 true

- `lock()` 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr
