# hw面经

## 机考 0831

1. 字符串索引替换  
- 给定一句话，再给定一个字典，把这句话中所有单词替换为单词在字典中的索引，不区分大小写。  
- 句子中包括逗号，句号，空格等符号，且双引号中的单词不需要替换。
    ```
    Hello, I will go to the "New World Park".
    hEllo  TO  park
    0, I will go 1 the "New World Park".
    ```

- 原理很简单，只是处理起来有点恶心，简单来说就是双指针记录单词起始和终止位置，但是同时需要用flag标注当前的状态，是否在双引号中，是否在单词中。
- 源码：[hw1.cc](./hw1.cc)

2. 扫雷  
- m*n的迷宫，从迷宫的左上角走到右下角，输出最短路径。  
- 其中，0为路，1为墙，2为起点，3为终点，4为陷阱可以走需要3个单位时间，6是炸弹，可以走，且可以将周围相邻4面墙炸开。
    ```
    4 4
    1 1 1 1
    1 6 2 1
    1 1 0 1
    1 3 1 1

    3
    ```
- 用A*算法，疯狂剪枝，同时dfs递归搜索，对于炸弹进行特殊处理，需要先记录哪些墙变为炸弹，回退后需要将墙还原。
- 源码：[hw2.cc](./hw2.cc)

3. 充电桩  
- 两城D公里远，给定1000公里续航的一辆车航速固定100公里/h从一地到另一地。
- 中间给定N个供充电的休息站距离出发点距离和各自充电需要排队的时间，在休息站都能耗时一小时充满电  
- 计算出从A地到B地的最短时间
    ```
    1500  4
    300   0
    600   1
    1000  0
    1200  1

    16
    (行驶1000公里到达第三个站点，用时10小时，然后充电1小时，继续行驶5小时到达终点，总路程1500公里，总时间10+1+5=16)
    ```

- 动态规划：`dp[i][j]` 表示从第 i 个充电桩走到终点，且剩余公里数为 j 的时候，需要的最短时间。
- 转移方程：用d表示当前充电桩距离下一个的距离
    - 当j > d时：可以选择在当前充电桩充电或者不充  
    `dp[i][j] = min(dp[i+1][j-d] + d/100, dp[i+1][1000-d] + d/100 + wait[i] + 1)`
    - 当 j < d 时，必须选择充电，否则无法走下去  
    `dp[i][j] = dp[i+1][1000-d] + d/100 + wait[i] + 1`
- 初始化数组：可以发现i是从后向前的，j是从前向后的
    - `dp[N][j]`

- 源码：[hw3.cc](./hw3.cc)