# 程序员的自我修养 -- 链接、装载与库


<!-- vscode-markdown-toc -->
* 1. [第一章](#)
	* 1.1. [ 从 hello world 说起](#helloworld)
	* 1.2. [ 万变不离其宗](#-1)
	* 1.3. [站的高，看得远](#-1)
	* 1.4. [OS做什么](#OS)
		* 1.4.1. [不要让CPU打盹](#CPU)
		* 1.4.2. [设备驱动](#-1)
	* 1.5. [内存不够怎么办](#-1)
		* 1.5.1. [关于隔离](#-1)
		* 1.5.2. [分段(segmentation)](#segmentation)
		* 1.5.3. [分页(Paging)](#Paging)
	* 1.6. [众人拾柴火焰高](#-1)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->


##  1. <a name=''></a>第一章

###  1.1. <a name='helloworld'></a> 从 hello world 说起

**这一节提出来几个问题，看完书以后应该对这些问题给出清晰明确的答案**

- 程序为什么要被编译器编译后才能执行

- 编译器在把C语言程序转换成可以执行的机器码的过程中做了什么，怎么做的

- 最后编译出的可执行文件里面是什么，除了机器码还有什么？怎么存放的，怎么组织的

- `#include<stdio.h>`是什么意思，把`stdio.h`包含进来意味着这么？C语言库又是什么，怎么实现的？

- 不同编译器(MS VC, GCC)和不同的硬件平台(x86, SPARC, MIPS, ARM)以及不同的操作系统(Windows, Linux, UNIX, Solaris)，最终编译出的结果一样吗，为什么？

- Hello World 程序是怎么运行起来的，操作系统是什么装载程序的，从哪里开始执行，到哪里结束，main函数之前发生了什么？main函数结束之后发生了什么？

- 如果没有操作系统，Hello World 可以运行吗，如果一台没有 OS 的机器需要运行程序需要什么，应该怎么实现？

- `printf()`是怎么实现的，为什么参数可变，为什么能在终端输出字符？

- Hello World 程序在运行时，它在内存中是什么样子的？

###  1.2. <a name='-1'></a> 万变不离其宗

- 早期计算机硬件结构
```
				  I/O device
                    |
CPU     Memory   xx controller    ...
|         |         |
+---------+---------+--------------+---- ...
                 BUS
```
- 北桥芯片：高速，协调CPU、内存和高速图形设备

- 南桥芯片：低速，连接芯片、磁盘、USB、键盘、鼠标等设备

- PCI总线，ISA总线 [TODO]

- 对称多处理器 SMP(Symmetrical Multi-Processing) <br>
每个CPU在系统所处的地位和所发挥的功能是一样的，相互对称的

- 多核处理器：只保留多个核心，共享比较昂贵的缓存部件，以一个处理器的包装出售 <br>
从程序员角度，可以把多核和SMP看作一个概念，细节上不同而已

###  1.3. <a name='-1'></a>站的高，看得远

> Any problem in computer science can be solved by another layer of indirection  
> 计算机领域的任何问题都可以通过增加一个间接的中间层解决

这句话几乎概括计算机系统软件体系结构设计要点

```
+-----------------+
|  App/Dev tools  |
+-----------------+----> OS API
| Runtime Library |
+-----------------+----> System Call
|    OS kernal    |
+-----------------+----> Hardware Specification
|     Hardware    |
+-----------------+
```
- 接口：通信的协议
- 操作系统应用程序编程接口(OS API)：由运行库提供接口
- 系统调用接口(System Call)：实现上以软中断方式提供
- 硬件规格(Hardware Specification)：硬件厂商负责提供硬件规格，OS和驱动开发者通过读硬件规格文档规定的接口标准来写OS和驱动

###  1.4. <a name='OS'></a>OS做什么

- OS的两个主要功能：
	- 提供抽象的接口
	- 管理硬件资源

- OS的主要资源类型
	- CPU
	- 存储器(内存和磁盘)
	- I/O设备

####  1.4.1. <a name='CPU'></a>不要让CPU打盹

- 多道程序：在CPU不使用的时候，通过调度其他等待CPU资源的程序启动
- 分时系统：每个程序运行一段时间后，主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一段时间，对于交互式的系统来说比较重要
- 多任务系统：OS接管所有硬件资源，自身在受硬件保护的级别，所有应用以进程的方式运行，在比系统权限更低的级别。每个进程有独立的地址空间，进程之间相互隔离。
- 抢占式：每个进程根据优先级高低分配CPU时间，但是当运行超出一定时间，OS会暂定进程，将CPU分配给其他等待的进程。**OS强制剥夺CPU资源分配给OS认为应该分配的进程。**

####  1.4.2. <a name='-1'></a>设备驱动

- 硬件驱动程序：独立于内核，OS为硬件厂商提供一系列接口和框架，让硬件厂商按照标准开发驱动程序，使得硬件可以在操作系统上使用

以硬盘读取为例；
- 硬盘简介
	- 硬盘 -> 盘片 -> 磁道 -> 扇区 -> 512 bytes
	- 一个硬盘有多个盘片，盘片分双面，每一面的按照同心圆划分为不同磁道，每个磁道分扇区。

- 硬盘读取步骤
	- 调用`read()`系统调用
	- 驱动程序收到请求，向硬件发出硬件命令，向端口写地址和数据
	- 例如：我们需要读取1000号逻辑扇区开始的第8个扇区
		- I/O端口为：0x1F0-0x1F7和0x376-0x377，其中0x1F3-0x1F6写LBA地址，0x1F2写扇区数8，0x1F7写操作码0x20
		- 1000号逻辑扇区的LBA为0x000003E8
		- 
			```
			out 0x1F3, 0x00
			out 0x1F4, 0x00
			out 0x1F5, 0x03
			out 0x1F6, 0xE8
			out 0x1F2, 8
			out 0x1F7, 0x20
			```

###  1.5. <a name='-1'></a>内存不够怎么办

如何将有限的物理内存分配给多个程序使用？

- 如果用物理地址分配
	- 进程之间不隔离：可以修改其他进程数据
	- 内存使用效率低：需要的空间连续，只能换入换出切换，效率低
	- 程序运行的地址不确定：涉及到程序重定位问题

解决：**虚拟地址映射**

####  1.5.1. <a name='-1'></a>关于隔离

- 虚拟地址空间：虚拟的，并不存在，每个进程有自己独立的虚拟空间，每个进程只能访问自己的地址空间，用虚拟内存做到了进程隔离
- 物理地址空间：可以认为物理内存，计算机只有唯一的物理地址空间

####  1.5.2. <a name='segmentation'></a>分段(segmentation)

- 分段：将程序所需要的内存空间大小的虚拟空间映射到某个地址空间  
分段解决了进程隔离和确定运行地址的问题，但内存使用效率低

####  1.5.3. <a name='Paging'></a>分页(Paging)

- 局部性原理：当程序在运行时，在一个时间段内用到的数据趋近于聚集在一个较小的连续区域内。

- 分页：把地址空间分为固定大小的页，每一页的大小由硬件决定，或者由OS选择决定页的大小。目前基本是4KB大小的页。

- 虚拟页，物理页，磁盘页

- MMU(Memory Management Unit)：内存管理单元，进行虚拟地址到物理地址的映射

	```
	+-----+  virtual addr  +-----+  physical addr   +-----------------+
	| CPU | -------------> | MMU | ---------------> | physical memory |
	+-----+                +-----+                  +-----------------+
	```
	- 所以程序中看到的是虚拟地址，经过 MMU 转换为物理地址。

###  1.6. <a name='-1'></a>众人拾柴火焰高

#### 线程基础

**线程定义**
- 线程：轻量级进程，程序执行流的最小单元
- 线程组成：线程ID，当前指令指针PC，寄存器集合，栈
- 一个进程由多个线程组成，线程之间共享程序内存空间(代码段，数据段，堆等等)，进程级资源(打开文件，信号)
- 为什么使用线程：
	- 某个操作可能会陷入长时间等待，多线程执行可以利用等待的时间。例如：等待网络响应
	- 某个操作会消耗大量的时间(例如计算)，多线程可以让一个线程负责交互，另一个负责计算
	- 程序逻辑本身就要求并发操作
	- 多CPU或多核计算机，本身同时具备同时执行多个线程的能力
	- 相比多进程，多线程在数据共享上高效
---

**线程访问权限**
- 线程私有资源
	- 栈
	- 线程局部存储(Thread Local Storage, TLS)
	- 寄存器
- 线程共享资源
	- 全局变量
	- 堆上的数据
	- 函数里的静态变量
	- 程序代码
	- 打开的文件
---

**线程调度和优先级**
- 线程调度：当线程数量小于处理器数量时，线程的并发是真正的并行，但对于线程数量大于处理器数量时，线程的并发会收到一些阻碍
- 线程调度：处理器切换线程的行为  
	- 线程至少拥有3种状态
		- 运行：正在执行
		- 就绪：此时可以立即运行，但CPU已经被占用
		- 等待：等待某一事件的发生，无法执行
	- 线程状态切换
		```
		        无线程运行，且该线程被选中
		     +----------------------------+
             |                            |
             v                            |
		+---------+    时间片用尽      +-------+
		| running | ----------------> | ready |
		+---------+                   +-------+
             |                            ^
             |         +------+           |
			 +-------> | wait | ----------+
			           +------+
		
		```
		- 时间片用尽的时候，线程从运行进入就绪状态。
		- 如果在时间片用尽前，线程就开始等待某事件，那么将进入等待状态
		- 每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行
		- 在一个等待状态的线程等待的事件发生后，线程进入就绪状态

- 优先级调度，轮转法
- I/O密集型线程频繁进入等待状态，CPU密集型线程很少等待
- 饿死：由于线程的优先级较低，执行之前总有较高优先级的线程执行，因此这个线程总是得不到执行

- 线程优先级改变方式
	- 用户指定
	- 根据等待状态的频繁程度
	- 长时间得不到执行的线程提升优先级
---

**抢占和不可抢占**
- 抢占：线程用尽时间片后，会被强制剥夺继续执行的权利，进入就绪状态
- 不可抢占线程：线程只有主动进入就绪才能调度
	- 线程主动放弃事件
	- 线程主动放弃时间片

---

**Linux的多线程**
- Windows的实现：内核有明确的进程和线程的概念，`CreateProcess`创建进程，`CreateThread`创建线程。
- Linux不存在真正的线程的概念。无论进程还是线程，将所有执行实体称为任务(Task)，每个任务类似于一个单线程的进程。可以通过共享内存空间来实现多线程

| 系统调用 | 作用 |
| --- | --- |
| `fork` | 复制当前进程 |
| `exec` | 使用新的可执行映像覆盖当前可执行映像 |
| `clone`| 创建子进程，从指定位置开始执行 |

`fork`函数调用后，新的任务启动，且和本任务一起从`fork`函数返回，本任务返回新任务的`pid`，新任务返回`0`
```
pid_t pid;
if (pid = fork()) {
	// father process
} else {
	// son process
}
```
fork出新任务的时候，并不会复制原任务的内存空间，而是和原任务一起共享一个COW的内存空间。
- 写时复制(Copy on Write, COW)：多个任务可以同时读取内存，但是任意一个任务试图对内存进行修改时，内存就会复制一份给该任务单独使用


